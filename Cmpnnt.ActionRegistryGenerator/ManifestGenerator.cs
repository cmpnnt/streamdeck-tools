using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Cmpnnt.ActionRegistryGenerator;

[Generator]
public class ManifestModelSourceGenerator : IIncrementalGenerator
{
    private const string COMMON_PLUGIN_FUNCTIONS = "BarRaider.SdTools.Backend.ICommonPluginFunctions";
    private const string KEYPAD_PLUGIN = "BarRaider.SdTools.Backend.IKeypadPlugin";
    private const string ENCODER_PLUGIN = "BarRaider.SdTools.Backend.IEncoderPlugin";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Debugger.Launch(); // Uncomment to debug

        // Find all class declarations potentially inheriting from the target interface
        IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null)!;

        // Combine classes with compilation
        IncrementalValueProvider<(Compilation, System.Collections.Immutable.ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses =
            context.CompilationProvider.Combine(classDeclarations.Collect());

        // Register the generation function
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    static bool IsSyntaxTargetForGeneration(SyntaxNode node) =>
        node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 };

    static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context) =>
        context.Node as ClassDeclarationSyntax;

    static void Execute(Compilation compilation, System.Collections.Immutable.ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty) return;

        var pluginActions = new List<ActionInfo>();
        string? firstNamespace = null;

        INamedTypeSymbol? commonInterfaceSymbol = compilation.GetTypeByMetadataName(COMMON_PLUGIN_FUNCTIONS);
        INamedTypeSymbol? keypadInterfaceSymbol = compilation.GetTypeByMetadataName(KEYPAD_PLUGIN);
        INamedTypeSymbol? encoderInterfaceSymbol = compilation.GetTypeByMetadataName(ENCODER_PLUGIN);

        if (commonInterfaceSymbol == null)
        {
            return;
        }

        // Analyze classes
        foreach (ClassDeclarationSyntax classDec in classes)
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(classDec.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(classDec) is not { IsAbstract: false } classSymbol) continue; // Ignore abstract classes
            if (!ImplementsInterface(classSymbol, commonInterfaceSymbol)) continue;
            
            string fullClassName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", "");
            string namespaceName = classSymbol.ContainingNamespace?.ToDisplayString() ?? string.Empty;

            firstNamespace ??= string.IsNullOrEmpty(namespaceName) ? null : namespaceName;

            bool isKeypad = keypadInterfaceSymbol != null && ImplementsInterface(classSymbol, keypadInterfaceSymbol);
            bool isEncoder = encoderInterfaceSymbol != null && ImplementsInterface(classSymbol, encoderInterfaceSymbol);

            pluginActions.Add(new ActionInfo(fullClassName, namespaceName, isKeypad, isEncoder));
        }

        if (!pluginActions.Any()) return; // No concrete actions found
        
        var sourceBuilder = new StringBuilder();
        BuildSource(sourceBuilder, pluginActions, firstNamespace);

        context.AddSource("GeneratedManifestModel.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
    }
    
    private static void BuildSource(StringBuilder sb, List<ActionInfo> actions, string? rootNamespace)
    {
        sb.AppendLine("""
                      // <auto-generated/>
                      // DO NOT MODIFY

                      using System;
                      using System.Text.Json.Serialization;
                      using System.Collections.Generic;

                      namespace GeneratedManifest
                      {
                          #nullable enable
                          internal class ManifestRoot
                          {
                              [JsonPropertyName("$schema")]
                              public string Schema { get; set; } = "https://schemas.elgato.com/streamdeck/plugins/manifest.json";
                              [JsonPropertyName("Actions")]
                              public List<ManifestAction> Actions { get; set; } = new List<ManifestAction>();
                              [JsonPropertyName("Author")]
                              public string Author { get; set; } = "BarRaider";
                              [JsonPropertyName("Description")]
                              public string Description { get; set; } = "Sample Plugin to test SDTools";
                              [JsonPropertyName("Name")]
                              public string Name { get; set; } = "SDTools Sample Plugin";
                              [JsonPropertyName("Icon")]
                              public string Icon { get; set; } = "Images/pluginIcon";
                              [JsonPropertyName("URL")]
                              public string Url { get; set; } = "https://barraider.com/";
                              [JsonPropertyName("Version")]
                              public string Version { get; set; } = "0.1.0.1";
                              [JsonPropertyName("CodePath")]
                              public string? CodePath { get; set; } // Set below
                              [JsonPropertyName("Category")]
                              public string Category { get; set; } = "SDTools Sample Plugin";
                              [JsonPropertyName("CategoryIcon")]
                              public string CategoryIcon { get; set; } = "Images/categoryIcon";
                              [JsonPropertyName("OS")]
                              public List<OsInfo> Os { get; set; } = new List<OsInfo> { new OsInfo() };
                              [JsonPropertyName("SDKVersion")]
                              public int SdkVersion { get; set; } = 2;
                              [JsonPropertyName("Software")]
                              public SoftwareInfo Software { get; set; } = new SoftwareInfo();
                              [JsonPropertyName("UUID")]
                              public string? Uuid { get; set; } // Set below
                          }
                      
                          internal class ManifestAction
                          {
                              [JsonPropertyName("Icon")]
                              public string Icon { get; set; } = "Images/icon";
                              [JsonPropertyName("Name")]
                              public string Name { get; set; } = "SDTools Test"; // Default
                              [JsonPropertyName("Controllers")]
                              public List<string> Controllers { get; set; } = new List<string>(); // Set below
                              [JsonPropertyName("Encoder")]
                              public EncoderInfo? Encoder { get; set; } = new EncoderInfo(); // Default based on template
                              [JsonPropertyName("States")]
                              public List<StateInfo> States { get; set; } = new List<StateInfo> { new StateInfo() };
                              [JsonPropertyName("SupportedInMultiActions")]
                              public bool SupportedInMultiActions { get; set; } = true;
                              [JsonPropertyName("Tooltip")]
                              public string Tooltip { get; set; } = "Sample Plugin to Test SDTools"; // Default
                              [JsonPropertyName("PropertyInspectorPath")]
                              public string PropertyInspectorPath { get; set; } = "PropertyInspector/Sample.html";
                              [JsonPropertyName("UUID")]
                              public string? Uuid { get; set; } // Set below
                          }

                          internal class OsInfo
                          {
                              [JsonPropertyName("Platform")]
                              public string Platform { get; set; } = "windows";
                              [JsonPropertyName("MinimumVersion")]
                              public string MinimumVersion { get; set; } = "10";
                          }
                      
                          internal class SoftwareInfo
                          {
                              [JsonPropertyName("MinimumVersion")]
                              public string MinimumVersion { get; set; } = "6.4";
                          }
                      
                           internal class EncoderInfo
                          {
                              [JsonPropertyName("layout")]
                              public string Layout { get; set; } = "$B1";
                              [JsonPropertyName("TriggerDescription")]
                              public EncoderTriggerDescription TriggerDescription { get; set; } = new EncoderTriggerDescription();
                          }
                      
                           internal class EncoderTriggerDescription
                          {
                              [JsonPropertyName("Push")]
                              public string Push { get; set; } = "Play / Pause";
                              [JsonPropertyName("Rotate")]
                              public string Rotate { get; set; } = "Adjust Volume";
                              [JsonPropertyName("Touch")]
                              public string Touch { get; set; } = "Play / Pause";
                              [JsonPropertyName("LongTouch")]
                              public string LongTouch { get; set; } = "Skip Track";
                          }
                      
                           internal class StateInfo
                          {
                              [JsonPropertyName("Image")]
                              public string Image { get; set; } = "Images/pluginAction";
                              [JsonPropertyName("TitleAlignment")]
                              public string TitleAlignment { get; set; } = "middle";
                              [JsonPropertyName("FontSize")]
                              public int FontSize { get; set; } = 12;
                          }
                      
                          /// <summary>
                          /// Provides access to the manifest data derived at compile time.
                          /// </summary>
                          internal static class ManifestProvider
                          {
                              private static readonly ManifestRoot _manifestData = CreateManifestData();
                      
                              /// <summary>
                              /// Gets the pre-populated manifest data object.
                              /// </summary>
                              public static ManifestRoot GetManifestData() => _manifestData;
                      
                              private static ManifestRoot CreateManifestData()
                              {
                                  var root = new ManifestRoot();
                      
                                  // Set Root UUID and CodePath based on first namespace found

                      """); // End initial part of generated file string

        // Set Root UUID and CodePath
        var rootUuid = "com.example.myplugin";
        if (!string.IsNullOrEmpty(rootNamespace))
        {
            rootUuid = $"{rootNamespace?.ToLowerInvariant()}";
        }
        sb.AppendLine($"""            root.Uuid = "{EscapeString(rootUuid)}";""");
        sb.AppendLine($"""            root.CodePath = "{EscapeString(rootUuid)}.exe"; // Default CodePath based on UUID""");

        // Add Actions
        sb.AppendLine();
        sb.AppendLine("            // Add Actions");
        foreach (ActionInfo? action in actions)
        {
            sb.AppendLine("            {"); // Start action block
            sb.AppendLine("                var action = new ManifestAction();");
            sb.AppendLine($"""                action.Uuid = "{EscapeString(action.FullClassName.ToLowerInvariant())}";""");

            // Set Controllers
            sb.Append("                action.Controllers = new List<string> { ");
            List<string> controllers = [];
            if (action.IsKeypad) controllers.Add("\"Keypad\"");
            if (action.IsEncoder) controllers.Add("\"Encoder\"");
            sb.Append(string.Join(", ", controllers));
            sb.AppendLine(" };");

            // Optional: Override Name and Tooltip based on Class Name
            sb.AppendLine($"""                action.Name = "{EscapeString(action.ClassName)}";""");
            sb.AppendLine($"""                action.Tooltip = "Action for {EscapeString(action.ClassName)}";""");

            // Add default EncoderInfo only if it's an encoder action? Or keep for all like template?
            // Keeping for all for now to match template exactly. Add condition if needed:
            // if (action.IsEncoder) sb.AppendLine("action.Encoder = new EncoderInfo();"); else sb.AppendLine("action.Encoder = null;");

            sb.AppendLine("                root.Actions.Add(action);");
            sb.AppendLine("            }"); // End action block
            sb.AppendLine();
        }

        // Finish Provider Class
        sb.AppendLine("""
                      
                                  return root;
                              }
                          }
                      }
                      """); // End namespace GeneratedManifest

    }


    // Helper Methods

    static bool ImplementsInterface(INamedTypeSymbol? classSymbol, INamedTypeSymbol? interfaceSymbol)
    {
        if (classSymbol == null || interfaceSymbol == null) return false;
        if (interfaceSymbol.TypeKind != TypeKind.Interface) return false;

        // Check direct interfaces and all base interfaces
        return classSymbol.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i.OriginalDefinition, interfaceSymbol.OriginalDefinition));

        // No need to check base types explicitly, AllInterfaces covers the hierarchy
    }

    // Escapes a string for embedding within a C# string literal
    static string EscapeString(string? value)
    {
        if (value == null) return string.Empty;
        // Basic escaping for quotes and backslashes
        return value.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }

    // Simple record to hold action info
    private record ActionInfo(string FullClassName, string Namespace, bool IsKeypad, bool IsEncoder)
    {
        // Gets the simple class name without the namespace
        public string ClassName => FullClassName.Contains('.') ? FullClassName.Substring(FullClassName.LastIndexOf('.') + 1) : FullClassName;
        public string FullClassName { get; } = FullClassName;
        public string Namespace { get; } = Namespace;
        public bool IsKeypad { get; } = IsKeypad;
        public bool IsEncoder { get; } = IsEncoder;
    }
}